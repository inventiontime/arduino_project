////////////////////////////////////////////////   Pins   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const int txPin = 2;
const int rxPin = A0;
const int lightPin = 3;
const int piezoPin = 11;
const int ldrPin = 4;
const int trafficPin[3] = {13, 12, 8};

////////////////////////////////////////////////   Boolean   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
boolean prevR = LOW;
boolean r = LOW;
boolean ldrState = LOW;
boolean delayA = false;

////////////////////////////////////////////////   Integer   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int valIR = 0;
int prevMillisT;
int prevMillisP;
int trafficState = 1;

////////////////////////////////////////////////   AppInterface   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte info[7];
boolean trafficOn = true;
int trafficD[3] = {1, 1, 1};
int lightD = 0;
int lightI = 55;
int irThreshold;

////////////////////////////////////////////////   Setup   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup() {
  // to set pinmodes
  pinMode(rxPin, INPUT);
  pinMode(txPin, OUTPUT);
  pinMode(ldrPin, INPUT);
  pinMode(lightPin, OUTPUT);
  pinMode(piezoPin, OUTPUT);
  pinMode(trafficPin[0], OUTPUT);
  pinMode(trafficPin[1], OUTPUT);
  pinMode(trafficPin[2], OUTPUT);

  // to begin serial communication for AppInterface
  Serial.begin(9600);
  Serial.write(1);

  // for timing
  prevMillisT = millis();
  prevMillisP = millis();
}

////////////////////////////////////////////////   Loop   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void loop() {
  reciveInfo();
  readInfo();
  streetL();
  trafficL();
}

////////////////////////////////////////////////   trafficL   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void trafficL() {
  if(trafficOn){
    if(millis() > prevMillisT + trafficD){
      switch(trafficState){
        case 0:
          trafficState++;
          digitalWrite(trafficPin[1], HIGH);
          digitalWrite(trafficPin[0], LOW);
          digitalWrite(trafficPin[2], LOW);
          break;

        case 1:
          trafficState++;
          digitalWrite(trafficPin[2], HIGH);
          digitalWrite(trafficPin[0], LOW);
          digitalWrite(trafficPin[1], LOW);
          break;

        case 2:
          trafficState = 0;
          digitalWrite(trafficPin[0], HIGH);
          digitalWrite(trafficPin[1], LOW);
          digitalWrite(trafficPin[2], LOW);
          break;
      }
      prevMillisT = millis();
    }
  }
}

////////////////////////////////////////////////   streetL   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void streetL() {
  // power saving with ldr
  ldrState = digitalRead(ldrPin);
  if(ldrState){
    // to sense obstruction and give output
    valIR = analogRead(rxPin);
    if(valIR < irThreshold){
      analogWrite(lightPin, 20); // 20 to be changed to 255
      prevR = r;
      r = HIGH;
    }else{
      analogWrite(lightPin, lightI);
      prevR = r;
      r = LOW;
      
    }
  
    // to give delay for pedestrians
    if(prevR == HIGH && r == LOW && delayA == true){
      analogWrite(lightPin, 20);
      delay(lightD);
    }

    // to start timer for piezo
    if(prevR == LOW && r == HIGH && delayA == true){
      prevMillisP = millis();
    }

    // to start piezo
    if(millis() - prevMillisP > 10000){
      digitalWrite(piezoPin, HIGH);
    }else{
      digitalWrite(piezoPin, LOW);
    }
    
  }else{
    analogWrite(lightPin, 0);
  }
}

////////////////////////////////////////////////   reciveInfo   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void reciveInfo(){
  for(int i = 0; i < 7; i++){
    if(Serial.available()){
      info[i] = Serial.read();
    }else{
      i--;
    }
  }
  Serial.write(1);
}

////////////////////////////////////////////////   readInfo   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void readInfo(){
  trafficOn = boolean(info[0]);
  trafficD[0] = int(info[1]);
  trafficD[1] = int(info[2]);
  trafficD[2] = int(info[3]);
  lightD = int(info[4]);
  lightI = int(info[5]);
  irThreshold = int(info[6]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
