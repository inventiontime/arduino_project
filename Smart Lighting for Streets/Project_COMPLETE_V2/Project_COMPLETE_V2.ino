////////////////////////////////////////////////   Pins   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const int rxPins[5] = {A4, A3, A2, A1, A0};
const int lightPin[6] = {3, 5, 6, 9, 10, 13};
const int ldrPin = A5;
const int trafficPins[3] = {12, 8, 4};

////////////////////////////////////////////////   Boolean   //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
boolean r[5];
boolean delayA = true;

////////////////////////////////////////////////   Integer   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int valIR = 0;
int ldrState;
int ldrThreshold = 150;
long prevMillisT;
long prevMillisD[5];
int trafficState = 1;

////////////////////////////////////////////////   AppInterface   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte info[7];
boolean trafficOn = true;
int trafficD[3] = {1, 1, 1};
int lightD = 0;
int lightI = 55;
int irThreshold;

////////////////////////////////////////////////   Setup   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void setup() {
  // to set pinmodes
  for(int i = 0; i < 6; i++){
    pinMode(rxPins[i], INPUT);
    pinMode(lightPin[i], OUTPUT);
  }
  pinMode(ldrPin, INPUT);
  pinMode(trafficPins[0], OUTPUT);
  pinMode(trafficPins[1], OUTPUT);
  pinMode(trafficPins[2], OUTPUT);

  // to begin serial communication for AppInterface
  Serial.begin(9600);
  Serial.write(1);

  // for timing
  prevMillisT = millis();
  for(int i = 0; i < 5; i++){
    prevMillisD[i] = millis();
  }
}

////////////////////////////////////////////////   Loop   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void loop() {
  reciveInfo();
  readInfo();
  streetL();
  trafficL();
}

////////////////////////////////////////////////   trafficL   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void trafficL() {
  if(trafficOn){
    if(millis() > prevMillisT + (trafficD[trafficState] * 1000)){
      switch(trafficState){
        case 0:
          trafficState++;
          digitalWrite(trafficPins[1], HIGH);
          digitalWrite(trafficPins[0], LOW);
          digitalWrite(trafficPins[2], LOW);
          break;

        case 1:
          trafficState++;
          digitalWrite(trafficPins[0], HIGH);
          digitalWrite(trafficPins[2], LOW);
          digitalWrite(trafficPins[1], LOW);
          break;

        case 2:
          trafficState = 0;
          digitalWrite(trafficPins[2], HIGH);
          digitalWrite(trafficPins[1], LOW);
          digitalWrite(trafficPins[0], LOW);
          break;
      }
      prevMillisT = millis();
    }
  }else{
    digitalWrite(trafficPins[0], LOW);
    digitalWrite(trafficPins[1], LOW);
    digitalWrite(trafficPins[2], LOW);
  }
}

////////////////////////////////////////////////   streetL   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void streetL() {
  // power saving with LDR
  ldrState = analogRead(ldrPin);                                                                                      //!!!!!!
  if(ldrState < ldrThreshold){

    for(int i = 0; i < 6; i++){
      // to dim the lights
      analogWrite(lightPin[i], lightI);
    }
    
    for(int i = 0; i < 6; i++){
      // to make delay work
      if(millis() > prevMillisD[i] + (lightD * 500)){
        r[i] = false;
      }
      
      // to sense obstruction and give output
      valIR = analogRead(rxPins[i]);
      if(valIR < irThreshold){
        analogWrite(lightPin[i], 255);
        analogWrite(lightPin[i + 1], 255);
        r[i] = true;
        prevMillisD[i] = millis();
      }else if(r[i]){
        analogWrite(lightPin[i], 255);
        analogWrite(lightPin[i + 1], 255);
      }
    }
  }else{
    for(int i = 0; i < 6; i++){
      analogWrite(lightPin[i], 0);
    }
  }
}

////////////////////////////////////////////////   reciveInfo   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void reciveInfo(){
  for(int i = 0; i < 7; i++){
    if(Serial.available()){
      info[i] = Serial.read();
    }else{
      i--;
    }
  }
  Serial.write(1);
}

////////////////////////////////////////////////   readInfo   ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void readInfo(){
  trafficOn = boolean(info[0]);
  trafficD[0] = int(info[1]);
  trafficD[1] = int(info[2]);
  trafficD[2] = int(info[3]);
  lightD = int(info[4]);
  lightI = int(info[5]);
  irThreshold = int(info[6]);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////